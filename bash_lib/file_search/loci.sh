# TODO
# - test loci long-option behaviour, esp --dir and --exec
#   I think it will work with --dir=foo, but not --dir 'foo'
# - add option to filter with grep pattern, rather than only using sed
# - is std-args useful here?

# dependencies
import_func array_max

# locate with ERE regex patterns
alias eloci='loci --regex'

loci() (

    : "Convenient file search with locate

    Usage: loci [options] <pattern> [...]

    This function accepts options (see below), that modify the behaviour of \`locate\`
    or cause filters to be applied to the results. To ensure options are passed to
    \`locate\` rather than \`loci\`, pass '--' first. In \`loci\`, unlike with \`locate\`,
    patterns may not be inter-mixed with options.

    Pattern matching

    When running loci without options (\`loci <pattern>\`), simple patterns are
    interpreted as substrings to match against file basenames (as in \`locate
    -b\`) in a smart-case manner. That is, lowercase patterns are matched as in
    \`locate -i\`, but a non-escaped uppercase character causes the match to be
    case-sensitive.  These defaults can be modified using the '-j' (case-sensitive)
    and '-w' (whole-path) options.

    Unless a regex pattern is specified, a pattern that contains a non-escaped
    globbing metacharacter (*, ?, or []) is interpreted as a glob pattern. Thus,
    it must be formed as \`*<pattern>*\` to produce a substring match.

    Regex patterns match substrings by default. This behaviour can be reversed using
    \`-x\` (--exact-match), which anchors the regex pattern to the start and end of the
    filename or path.

    When multiple patterns are given, \`plocate\` will search for file paths that match
    all of them. This behaviour differs from the \`mlocate\` version of \`locate\`.

    Options

      -r (--regex)
      : Match as an unanchored ERE regular expression. This issues the \`--regex\`
        option to locate, rather than invoking \`--regexp\` for basic regex as
        \`locate -r\` normally would. This is also aliased as 'eloci'. Matching with
        regex may be slower than using glob patterns.

      -x (--exact-match)
      : Match the pattern against the full basename or path, rather than a substring.
        This also enables '-r', as it uses an anchored regex pattern.

      -W (--word)
      : Match the pattern as a word. In this context, word matching means the pattern is
        bounded by non-alphabetic charaters, or the start and end of the filename or
        path. Thus, e.g. '-W abc' would match 'def_abc1.txt'. When both '-W' and '-x' are
        used, '-W' takes priority. This also enables '-r', as it uses a regex pattern.

      -j (--case)
      : Match case sensitive.

      -. (--cwd, --here, --cwdP)
      : Only show matches from the current working directory (recursively). The cwdP
        variant resolves symlinks in path, using \`pwd -P\`. This also enables \`-r\`,
        as it uses an anchored regex pattern.

      -C \"path\" (--dir=\"path\")
      : Like --cwd, but uses the specified directory as the search root.

      --ls, --ll, --l1
      : Run \`ls\` on the matched files. The default command is \`ls -d --color=auto\`,
        while the \`ll\` variant adds \`-lh\`, and the \`l1\` variant adds \`-1\`.

      --exec=\"cmd args ...\"
      : Run an arbitrary command on the matched files. The command line undergoes
        word-splitting and is run using \`xargs\`, with the filenames as trailing
        arguments.

      -u (--updatedb)
      : Run \`updatedb\` to update the locate database before searching.

      -v (--verbose)
      : Print the locate command to STDERR as it is run.

    Notable \`locate\` options

        -i : case-insensitive search
        -b : match only against the file-name portion of the path
        -w : match against the entire path
        -c : count matches, do not print them
        -e : only report matches of files that exist
      -l N : stop searching after N matches have been found
        -0 : delimit matches by null character, rather than newline

    Notes

    - The database searched by plocate is generated by updatedb, and is located
        at \`/var/lib/plocate/plocate.db\` by default. The config file path is
        \`/etc/updatedb.conf\`. Refer to the man pages for \`updatedb\` and
        \`updatedb.conf\`.

    - The return status is 0 if there is any match, or 1 for no matches.

    - Unlike mlocate, plocate will store newline characters in filenames in its
        database. Both tools provide the -0 flag to separate results by null
        instead of newline. This allows the following code snippet to give
        legible output, with the newline printed as '\n':

        \`\`\`sh
        touch newline-$'\n'-filename
        ls -1b new*
        # newline-\n-filename

        sudo updatedb  # or locate.updatedb on macOS
        while IFS='' read -rd '' fn
        do
            printf 'fn: %s\n' \"\${fn@Q}\"
        done < <( locate -b0 newline )
        \`\`\`
    "
    [[ $# -eq 0 || $1 == @(-h|--help) ]] &&
        { docsh -TD; return; }

    # return on non-zero return status
    trap '
        trap-err $?
        return
    ' ERR

    trap '
        unset -f _run_loc _run_filt
        trap - err return
    ' RETURN

    # default 'locate -ib'
    # - NB adding -w later in the options over-rides -b here, so that works
    # - NB however, the -j / --case and smart-case logic depends on loc_opts[0]=-ib
    local loc_opts=( -ib )

    # default 'postprocessing' is just print to stdout
    local _pp_cmd=( printf '%s\n' )

    # terminate filenames with nulls rather than newlines
    local _nulls=1

    # parse args
    local _xact _word _reqpath _udb _v

    local flag OPTARG OPTIND=1

    while getopts ':rjxWuv.C:d:l:-:' flag
    do
        # handle long options
        _split_optarg flag

        # use var=${OPTARG:?} to display error msg and exit if OPTARG is Null or Unset
        case $flag in

            # loci options:
            ( r | regex )
                [[ ${loc_opts[-1]} == --regex ]] || loc_opts+=( --regex )
            ;;
            ( j | case )
                loc_opts[0]="-b"
            ;;
            ( x | exact-match )
                [[ ${loc_opts[-1]} == --regex ]] || loc_opts+=( --regex )
                _xact=1
            ;;
            ( W | word )
                [[ ${loc_opts[-1]} == --regex ]] || loc_opts+=( --regex )
                _word=1
            ;;
            ( u | updatedb )
                _udb=1
            ;;
            ( v | verbose )
                _v=1
            ;;
            ( . | cwd | here )
                _reqpath=$PWD
            ;;
            ( cwdP )
                _reqpath=$( pwd -P )
            ;;
            ( C | dir )
                # TODO: test
                _reqpath=$OPTARG
            ;;
            ( ls | ll | l1 )
                _pp_cmd=( ls -d --color=auto )
                [[ $flag == ll ]] && _pp_cmd+=( -lh )
                [[ $flag == l1 ]] && _pp_cmd+=( -1 )
            ;;
            ( exec )
                str_to_words _pp_cmd "$OPTARG"
            ;;

            # handle inter-mixed locate options that require an arg
            ( d | l )
                loc_opts+=( -$flag "$OPTARG" )
            ;;
            ( database | limit )
                [[ -v OPTARG ]] || {
                    # handle --limit LIMIT
                    OPTARG=${!OPTIND}
                    (( OPTIND++ ))
                }
                loc_opts+=( --$flag "$OPTARG" )
            ;;

            # other short and long option flags for locate
            # - getopts sets flag to literal '?' for an unknown short option
            ( \? )
                loc_opts+=( "-$OPTARG" )
            ;;
            ( : )
                err_msg 2 "missing arg for '$OPTARG'"
                return
            ;;
            ( ??* )
                loc_opts+=( "--$flag" )
            ;;
        esac
    done
    shift $(( OPTIND - 1 ))

    # the rest of the arguments must be patterns
    local pats=( "$@" )
    shift $#


    if [[ -n ${_udb-} ]]
    then
        # updatedb run requested

        if [[ $( uname -s ) == Darwin ]]
        then
            udb_cmd=$( builtin type -P locate.updatedb )
        else
            udb_cmd=$( builtin type -P updatedb )
        fi

        if [[ -v LOCATE_PATH ]]
        then
            # if LOCATE_PATH is set, the db file should be owned by the calling user
            [[ $( stat -c '%u' "$LOCATE_PATH" ) == "$EUID" ]] ||
                return

            "$udb_cmd"

        else
            # check that the database file is as expected:
            # -rw-r----- 1 root plocate 14M /var/lib/plocate/plocate.db
            local udb_fn=/var/lib/plocate/plocate.db

            [[ $( stat -c '%u:%g' "$udb_fn" ) == '0:114' ]] ||
                return

            [[ $( stat -c '%a' "$udb_fn" ) == '640' ]] ||
                return

            if [[ $EUID == 0 ]]
            then
                "$udb_cmd"
            else
                sudo "$udb_cmd"
            fi
        fi

        # return if no patterns were specified
        [[ -v pats ]] || return 0
    fi


    # enact the exact-match, word, and smart-case options
    local i pat

    for i in "${!pats[@]}"
    do
        pat=${pats[$i]}

        # smart-case: check for non-escaped uppercase letters in the pattern
        [[ $pat == [[:upper:]]*  ||  $pat == *[!\\][[:upper:]]* ]] && {

            [[ ${loc_opts[0]} == -ib ]] &&
                loc_opts[0]="-b"
        }

        if [[ -n ${_word-} ]]
        then
            # word: ensure the pattern is surrounded by non-alpha chars
            pats[$i]="(^|[^[:alpha:]])${pat}(\$|[^[:alpha:]])"

        elif [[ -n ${_xact-} ]]
        then
            # xact: anchor the pattern to match the full basename or path
            [[ ${pat:0:1} == '^' ]] || pat='^'"$pat"
            [[ ${pat:(-1)} == '$' ]] || pat="$pat"'$'
            pats[$i]="$pat"
        fi
    done

    # final locate args: opts and patterns
    # - except _nulls is used at the time of calling
    local loc_args=( "${loc_opts[@]}" "${pats[@]}" )

    _run_loc() {

        ## Run locate, possibly printing the command to STDERR
        # - return status will be that of locate
        (
            [[ -n ${_v-} ]] &&
                set -x
            locate "$@"
        )
    }

    _run_filt() {

        ## Filter locate output if requested
        # - NB, can't use '<<< "..."' or 'var=$(...)' with null-terminated lines
        # - start with a null filter
        local _f1='^' _f2=''

        [[ -n ${_reqpath-} ]] && {
            _f1+="$_reqpath"
            _f2='.'
        }

        _filt-sed "$_f1" "$_f2" < \
            <( _run_loc "$@" ) \
            || return

        ## Check locate return status from the process substitution
        # - NB, return status 1 is sometimes OK: it can be just nothing found, like
        #   grep. But it can also be an error, in which case it should print an error
        #   message.
        wait $! \
            || return
    }

    _filt-grep() {

        # filter locate results:
        #   - print only results matching a pattern
        #
        # usage:
        #   _filt-grep <pattern>

        local grep_path
        grep_path=$( builtin type -P grep ) \
            || return 9

        "$grep_path" ${_nulls:+-z} "$1"
    }

    _filt-sed() {
        # filter locate results:
        #   - only print results matching pattern
        #   - replace pattern with a string
        #
        # usage:
        #   _filt-sed <pattern> <replacement>

        local spth
        spth=$( builtin type -P sed )

        "$spth" -nE ${_nulls:+-z} "\\:$1: { s:$1:$2:; p; }"
    }


    # Run locate with any filtering and postprocessing
    local ps_arr=()

    # xargs:
    #  -0 : process nulls
    #  -r : don't run the command with empty input

    {
        _run_filt ${_nulls:+-0} "${loc_args[@]}" |
            xargs -r ${_nulls:+-0} "${_pp_cmd[@]}"
    } \
        && ps_arr=( "${PIPESTATUS[@]}" ) \
        || ps_arr=( "${PIPESTATUS[@]}" )

    # maybe use a mkfifo to capture the exit code:
    # trap 'rm foo.fifo' return
    # mkfifo foo.fifo
    # cmd1 < ( cmd2; echo $? > foo.fifo; )
    # read rs < foo.fifo

    # or like this
    # fifo1="/tmp/fifo1_$RANDOM"
    # trap 'rm "$fifo1"' RETURN
    # mkfifo "$fifo1"
    # cat < "$fifo1" &
    # ( true; echo $?; ) > "$fifo1" 2>&1
    # echo $?

    ## Check return status from the filtered locate process
    # also, maybe just use pipes, and check array_max on a copy of PIPESTATUS
    # - we're relying on sed and locate to print error messages if there was a real
    #   problem, otherwise exit code 1 should just mean locate didn't find anything.
    local -i rs_code
    rs_code=$( array_max ps_arr )

    return $rs_code
)
